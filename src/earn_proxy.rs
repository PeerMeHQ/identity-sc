// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct EarnProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for EarnProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = EarnProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        EarnProxyMethods { wrapped_tx: tx }
    }
}

pub struct EarnProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> EarnProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init(
        self,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> EarnProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> EarnProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn register_endpoint<
        Arg0: ProxyArg<Option<TokenIdentifier<Env::Api>>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        stake_token: Arg0,
        reward_token: Arg1,
        lock_time_seconds: Arg2,
        managers: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("register")
            .argument(&stake_token)
            .argument(&reward_token)
            .argument(&lock_time_seconds)
            .argument(&managers)
            .original_result()
    }

    pub fn distribute_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("distribute")
            .original_result()
    }

    pub fn renew_virtual_stake_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        entity: Arg0,
        user: Arg1,
        amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("renewVirtualStake")
            .argument(&entity)
            .argument(&user)
            .argument(&amount)
            .original_result()
    }

    pub fn set_virtual_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        entity: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setVirtual")
            .argument(&entity)
            .original_result()
    }

    pub fn update_manager_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        manager: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addManager")
            .argument(&manager)
            .original_result()
    }

    pub fn remove_manager_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        manager: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeManager")
            .argument(&manager)
            .original_result()
    }

    pub fn stake_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        entity: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("stake")
            .argument(&entity)
            .original_result()
    }

    pub fn withdraw_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        entity: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdraw")
            .argument(&entity)
            .argument(&amount)
            .original_result()
    }

    pub fn claim_reward_endpoint<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        entities: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRewards")
            .argument(&entities)
            .original_result()
    }

    pub fn get_earner_info_view<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        entity: Arg0,
        address: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EarnerInfo<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEarnerInfo")
            .argument(&entity)
            .argument(&address)
            .original_result()
    }

    pub fn get_all_earner_info_view<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, EarnerInfo<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllEarnerInfo")
            .argument(&address)
            .original_result()
    }

    pub fn set_platform_fee_endpoint<
        Arg0: ProxyArg<u32>,
    >(
        self,
        fee: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPlatformFee")
            .argument(&fee)
            .original_result()
    }

    pub fn set_platform_vault_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        vault: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPlatformVault")
            .argument(&vault)
            .original_result()
    }

    pub fn set_platform_entity_endpoint<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        entity: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPlatformEntity")
            .argument(&entity)
            .original_result()
    }

    pub fn pause_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        entity: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pause")
            .argument(&entity)
            .original_result()
    }

    pub fn unpause_endpoint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        entity: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unpause")
            .argument(&entity)
            .original_result()
    }

    pub fn platform_fee(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u32> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPlatformFee")
            .original_result()
    }

    pub fn platform_vault(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPlatformVault")
            .original_result()
    }

    pub fn platform_entity(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPlatformEntity")
            .original_result()
    }

    pub fn get_dao_vote_weight_view<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<TokenIdentifier<Env::Api>>>,
    >(
        self,
        address: Arg0,
        _token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDaoVoteWeight")
            .argument(&address)
            .argument(&_token)
            .original_result()
    }

    pub fn get_dao_members_view<
        Arg0: ProxyArg<OptionalValue<TokenIdentifier<Env::Api>>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        _token: Arg0,
        entity: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, BigUint<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDaoMembers")
            .argument(&_token)
            .argument(&entity)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct EarnerInfo<Api>
where
    Api: ManagedTypeApi,
{
    pub entity: ManagedAddress<Api>,
    pub entity_info: EntityInfo<Api>,
    pub stake_amount: BigUint<Api>,
    pub stake_locked_until: u64,
    pub reward_amount: BigUint<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct EntityInfo<Api>
where
    Api: ManagedTypeApi,
{
    pub stake_token: Option<TokenIdentifier<Api>>,
    pub reward_token: TokenIdentifier<Api>,
    pub lock_time_seconds: u64,
    pub last_reward_at: u64,
    pub last_reward_amount: BigUint<Api>,
    pub total_reward_amount: BigUint<Api>,
    pub paused: bool,
}
